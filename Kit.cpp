// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

/*  Kit.cpp
 * 
 *  Source file for the Kit class: This class represents a kit through it's kit 
 *  name and composing parts' numbers and quantities required.  Functions are 
 *  provided to construct a new kit object from a CSV file describing it, get 
 *  and set the kit's name, and to add parts to the kit.
 */

/************************************************************
 Kit class body
 ************************************************************/

// include associated header file
#include "Kit.h"

//CONSTRUCTOR
Kit::Kit()
{

}

Kit::Kit(std::string /*in*/filepath) 
{
	std::string line; // store the current record
	std::string lastPart; // store the partNo of the last part added
	std::array<std::string,3> toks; //store tokens from line n
	bool standardFormat = true; // track which file format is being processed
	
	std::ifstream CSV;
	CSV.open(filepath);

	if(CSV.is_open())
	{
		std::getline(CSV,line); // get first line
		toks = this->parseLine(line); // tokenize first line
		this->kitNo = toks[0]; // set kitNo

		std::getline(CSV,line); // skip line 2 ("Bill of Materials")
		std::getline(CSV,line); // skip line 3 (",,")
		std::getline(CSV,line); // skip line 4 ("Qty,Part Number,Description")

		while(getline(CSV, line))
		{
			toks = this->parseLine(line); // tokenize and store line n

			if(toks[0] == "Part Number")
			{
				//in the oddball file, Bias Board
				standardFormat = false;
			}

			switch(standardFormat) // are we in a nonstandard formatted file?
			{
				case false: //nonstandard format
				{
					//toks[0] = partNo
					//toks[1] = desc
					
					if(toks[0] == "Part Number")
					{
						//ignore this heading record
					}
					else
					{
						addPart("",toks[0],toks[1]);
					}
					
					break;
				} // end nonstandard case

				case true: // standard format
				{
					//toks[0] = quantity
					//toks[1] = part number
					//toks[2] = description

					// Scenario 1: Extended description 1 (junk qty, blank partNo, valid desc)
					// Scenario 2: Variable quantity 1 (junk qty, valid partNo and desc)
					// Scenario 3: Blank (all empty tokens)
					// Scenario 4: Extended description 2 (blank qty and desc, valid partNo)
					// Scenario 5: Extended description 3 (blank qty, nonblank partNo, blank desc)
					// Scenario 6: Standard (all valid tokens)

					if(toks[0] == "Qty")
					{
						//std::cout << "ignore" << '\n'; // REMOVE AFTER TESTING
						//ignore this heading line
					}
					else if(toks[0] == "" || toks[0] == "") // junk qty
					{
						if(toks[1] == "") // junk qty, blank partNo
						{
							//std::cout << "1: ext1" << '\n'; // REMOVE AFTER TESTING
							appendDesc(lastPart, toks[2]);
						}
						else // junk qty, nonblank partNo
						{
							//std::cout << "2: var1" << '\n'; // REMOVE AFTER TESTING
							addPart("varies", toks[1], toks[2]);
							lastPart = toks[1];
						}
					}
					else if(toks[0] == "") // blank qty
					{
						if(toks[1] == "") // blank qty, blank partNo
						{
							if(toks[2] == "") // blank qty, blank partNo, blank desc
							{
								//std::cout << "3: blank" << '\n'; // REMOVE AFTER TESTING
								//ignore this blank record
							}
							else // blank qty, blank partNo, nonblank desc
							{
								//std::cout << "4: ext2" << '\n'; // REMOVE AFTER TESTING
								appendDesc(lastPart, toks[2]);
							}
						}
						else // blank qty, nonblank partNo
						{
							//std::cout << "5: ext3" << '\n'; // REMOVE AFTER TESTING
							appendDesc(lastPart, toks[1]);
						}
					}
					else // nonblank & nonjunk qty
					{
						if(toks[1] == "") // nonblank & nonjunk qty, blank partNo
						{
							//ignore this record
							//std::cout << "ignore" << '\n'; // REMOVE AFTER TESTING
						}
						else // nonblank & nonjunk qty, nonblank partNo
						{
							//std::cout << "6: std" << '\n'; // REMOVE AFTER TESTING
							addPart(toks[0], toks[1], toks[2]);
							lastPart = toks[1];
						}
					}
					break;
				} // end standard case

			} // end switch

		} // end while loop iterating through records
		
		CSV.close();
	}
	else
	{
		std::cout << "Unable to open file.";
	}
} // end constructor

//VIRTUAL DESCTRUCTOR
Kit::~Kit()
{

}

//MEMBER FUNCTIONS

//The function addPart() adds the part number and qty to the kit object's map.
//It also adds the part to the master listing of parts shared among all instances
//of the kit class (if the part does not already exist).
void Kit::addPart(std::string qty, std::string partNo, std::string desc) 
{
	this->parts.insert(make_pair(partNo, qty));
	this->partsCatalog.insert(make_pair(partNo, Part(partNo, desc)));
}

//The function appendDesc() appends the passed desc string to the end of the
//existing description string for the given part number in the partsCatalog, IF
//this particular part has not already been appended.
void Kit::appendDesc(std::string partNo, std::string desc)
{
	if(std::find(this->appended.begin(), this->appended.end(), partNo) != this->appended.end())
	{
		// part description has already been appended do nothing
	}
	else
	{
		std::string tempDesc = this->partsCatalog.at(partNo).getDesc();
		this->partsCatalog.at(partNo).setDesc(tempDesc + desc);
		this->appended.push_back(partNo);
	}
}

//The function hasPart() returns true if the Kit contains the passed part.
bool Kit::hasPart(std::string partNo) const
{
	if(this->parts.find(partNo) == this->parts.end())
	{
		return false;
	}
	else
	{
		return true;
	}
}

//The function parseLine() takes a part line from the CSV files and splits it 
//into the appropriate tokens.
std::array<std::string,3> Kit::parseLine(std::string line)
{
	bool quoteTok = false; // tracks tokenizing when "blah, blah, blah"
	std::array<std::string, 3> toks; // stores qty, partNo, desc tokens
	int tokInd = 0; // 0 = qty, 1 = partNo, 2 = desc
	std::stringstream ss; //stream to feed chars of tokens into
	
	for(char& c : line) // iterate through line, char by char
	{
		//std::cout << "c: " << c << '\n'; //REMOVE AFTER TESTING
		
		if(quoteTok == false) // iterating through a qty or partNo?
		{
	 		if(c != ',' && c != '"') // char belongs in token
			{
				ss << c;
			}
			
			if(c == ',') // delimiting char?
			{
				if(tokInd < 3) // don't run off end of toks
				{
					toks[tokInd] = ss.str(); //assign stream to tok element
					++tokInd; // increment token index
					ss.str(std::string()); // clear the stream
				}
			}
			
			if(c == '"') // entering desc token?
			{
				quoteTok = true;
			}
		}
		else if(quoteTok == true) // iterating through a desc?
		{
			if(c != '"')
			{
				ss << c;
			}
			else if(c == '"')
			{
				if(tokInd < 3) // don't run off end of toks
				{
					toks[tokInd] = ss.str(); //assign stream to tok element
					quoteTok = false;
				}
			}
		}
	}
	
	if(tokInd < 3) // don't run off end of toks
	{
		toks[tokInd] = ss.str();
	}
	
	return toks;
}

//The function partQty() returns the quantity of the passed part required for the kit. 
std::string Kit::partQty(std::string partNo) const
{
	return this->parts.at(partNo);
}

//The function getDesc() searches the parts catalog for the passed part and returns
//the parts description if it exists.  An error message is displayed if it doesn't exist. 
std::string Kit::getDesc(std::string partNo) const
{
	try
	{
		return this->partsCatalog.at(partNo).getDesc();
	}
	catch(const std::out_of_range& oor)
	{
		std::cerr << partNo << " is not listed in any kits." << '\n';
	}
}

//The function getKitNo() returns the kit object's kit number as a string.
std::string Kit::getKitNo() const
{
	return this->kitNo;
}

//The function setKitNo() sets the kit objects kit number to the passed string.
void Kit::setKitNo(std::string /*in*/kitNo) 
{
	this->kitNo = kitNo;
}

/************************************************************
 End of kit class body
 ************************************************************/